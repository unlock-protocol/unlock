/**
 * Determine whether a key is valid based solely on its expiration
 *
 * @oaram {key} key a key object, which must contain an expiration timestamp in seconds
 * @returns bool
 */
export function isValidKey(key) {
  return key.expiration > new Date().getTime() / 1000
}

/**
 * Returns the textual status of a key based on its expiration and transaction
 * @param {key} key a key object, which must contain transactions and expiration
 * @param {int} requiredConfirmations the number of confirmations required to consider a transaction confirmed
 * @returns {none|submitted|pending|confirming|valid|expired|failed}
 */
export function getKeyStatus(key, requiredConfirmations) {
  let valid = isValidKey(key)
  if (!key.transactions || !key.transactions.length) {
    return valid ? 'valid' : 'none'
  }
  // if we reach this line, key.transactions has at least 1 transaction in it
  // the key transactions must be generated by linkTransactionsToKeys in order
  // to be properly sorted

  // For a brief period, a transaction that moves from "submitted" to
  // "confirming" will have an expiration of 0. We establish a special
  // case for that here to avoid a brief flicker of the "locked"
  // paywall state.
  valid = valid || key.expiration === 0

  const lastTransaction = key.transactions[0]
  switch (lastTransaction.status) {
    case 'mined':
      if (lastTransaction.confirmations < requiredConfirmations) {
        return valid ? 'confirming' : 'expired'
      }
      return valid ? 'valid' : 'expired'
    default:
      // NOTE: a key may technically expire while the transaction is pending, but
      // its timer only actually starts when the transaction is first confirmed
      // so users get the pending time for free
      return lastTransaction.status || 'none'
  }
}

/**
 * Construct the transactions field for a key
 * @param {object} key key to process
 * @param {object} transactions transactions, indexed by hash (submitted transaction is always
 *                              indexed under "submitted-${lock address}-${user account}")
 * @param {int} requiredConfirmations the number of confirmations needed to ensure a transaction went through
 */
export function linkTransactionsToKey({
  key,
  transactions,
  requiredConfirmations,
}) {
  const account = key && key.owner ? key.owner.toLowerCase() : null
  const lock = key && key.lock ? key.lock.toLowerCase() : null
  const keyPurchaseTransactions = Object.values(transactions)
    .filter(transaction => {
      // in theory, all transactions have already been filtered this way
      // but this is a sanity check to ensure we only process
      // key purchase transactions where the key was purchased
      // for the current account holder
      const forUser = transaction.for
        ? transaction.for.toLowerCase()
        : transaction.for
      const lockUser = transaction.lock
        ? transaction.lock.toLowerCase()
        : transaction.lock
      return forUser === account && lockUser === lock
    })
    // NOTE: submitted and pending transactions have an artificial blockNumber of Number.MAX_SAFE_INTEGER
    // set in walletService, so they are always the first transaction
    .sort((a, b) => (a.blockNumber > b.blockNumber ? -1 : 1))
  const fullKey = {
    ...key,
    status: getKeyStatus(key, requiredConfirmations),
    confirmations: 0,
    transactions: [],
  }
  if (!keyPurchaseTransactions.length) {
    return fullKey
  }
  fullKey.confirmations = keyPurchaseTransactions[0].confirmations
  fullKey.transactions = keyPurchaseTransactions
  fullKey.status = getKeyStatus(fullKey, requiredConfirmations)
  return fullKey
}

/**
 * Construct the transactions field for each key
 * @param {object} keys keys, indexed by their lock/owner ID (not the same as smart contract ID)
 * @param {object} transactions transactions, indexed by hash
 * @param {int} requiredConfirmations the number of confirmations needed to ensure a transaction went through
 */
export function linkTransactionsToKeys({
  keys,
  transactions,
  requiredConfirmations,
}) {
  return Object.values(keys).reduce(
    (newKeys, key) => ({
      ...newKeys,
      [`${key.lock}-${key.owner}`]: linkTransactionsToKey({
        key,
        transactions,
        requiredConfirmations,
      }),
    }),
    {}
  )
}
