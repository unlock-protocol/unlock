import { getAccount } from './account'

/**
 * Determine whether a key is valid based solely on its expiration
 *
 * @oaram {key} key a key object, which must contain an expiration timestamp in seconds
 * @returns bool
 */
export function isValidKey(key) {
  return key.expiration > new Date().getTime() / 1000
}

/**
 * Returns the textual status of a key based on its expiration and transaction
 * @param {key} key a key object, which must contain transactions and expiration
 * @param {int} requiredConfirmations the number of confirmations required to consider a transaction confirmed
 * @returns {none|submitted|pending|confirming|valid|expired|failed}
 */
export function getKeyStatus(key, requiredConfirmations) {
  const valid = isValidKey(key)
  if (!key.transactions || !key.transactions.length) {
    return valid ? 'valid' : 'none'
  }
  // if we reach this line, key.transactions has at least 1 transaction in it
  // the key transactions must be generated by linkTransactionsToKeys in order
  // to be properly sorted
  const lastTransaction = key.transactions[0]
  switch (lastTransaction.status) {
    case 'mined':
      if (lastTransaction.confirmations < requiredConfirmations) {
        return valid ? 'confirming' : 'expired'
      }
      return valid ? 'valid' : 'expired'
    default:
      // NOTE: a key may technically expire while the transaction is pending, but
      // its timer only actually starts when the transaction is first confirmed
      // so users get the pending time for free
      return lastTransaction.status || 'none'
  }
}

/**
 * Construct the transactions field for each key
 * @param {object} keys keys, indexed by their lock/owner ID (not the same as smart contract ID)
 * @param {object} transactions transactions, indexed by hash (submitted transaction is always
 *                              indexed under "submitted-${lock address}-${user account}")
 * @param {array} locks an array of lock addresses
 * @param {int} requiredConfirmations the number of confirmations needed to ensure a transaction went through
 */
export function linkTransactionsToKeys({
  keys,
  transactions,
  locks,
  requiredConfirmations,
}) {
  const account = getAccount()
  const newKeys = {}

  const transactionsByLock = locks.reduce((indexedTransactions, lock) => {
    // get the key purchase transactions sorted in reverse chronological order
    const keyPurchaseTransactions = Object.values(transactions)
      .filter(transaction => {
        return transaction.from === account && transaction.to === lock
      })
      // NOTE: submitted and pending transactions have an artificial blockNumber of Number.MAX_SAFE_INTEGER
      // set in walletService, so they are always the first transaction
      .sort((a, b) => (a.blockNumber > b.blockNumber ? -1 : 1))

    indexedTransactions[lock] = keyPurchaseTransactions
    return indexedTransactions
  }, {})

  Object.values(keys).forEach(key => {
    const fullKey = {
      ...key,
      status: getKeyStatus(key, requiredConfirmations),
    }
    if (!transactionsByLock[key.lock] || !transactionsByLock[key.lock].length) {
      newKeys[key.id] = fullKey
      return
    }
    fullKey.confirmations = transactionsByLock[key.lock][0].confirmations
    fullKey.transactions = transactionsByLock[key.lock]
    fullKey.status = getKeyStatus(fullKey, requiredConfirmations)
    newKeys[fullKey.id] = fullKey
  })

  return newKeys
}
