import { TransactionStatus, KeyStatus } from '../../unlockTypes'
import {
  getTransactionsFor,
  getLatestTransaction,
  transactionToKeyStatus,
  getHighestStatus,
  getKeyStatus,
} from '../../utils/keys'

describe('keys utils', () => {
  describe('getTransactionsFor', () => {
    it('filters an object of transactions for many keys into a list of transactions for 1 key', () => {
      expect.assertions(1)

      const transactions: any = {
        one: { lock: 'lock1' },
        two: { lock: 'lock2' },
        three: { lock: 'lock1' },
        four: { lock: 'lock3' },
      }

      const key: any = {
        lock: 'lock1',
      }

      expect(getTransactionsFor(transactions, key)).toEqual([
        { lock: 'lock1' },
        { lock: 'lock1' },
      ])
    })
  })

  describe('getLatestTransaction', () => {
    it('returns the transaction with the highest blockNumber', () => {
      expect.assertions(1)

      const transactions: any = [
        { blockNumber: 1 },
        { blockNumber: 12 },
        { blockNumber: -1 },
        { blockNumber: 100000000001 },
        { blockNumber: 5 },
        { blockNumber: 908 },
        { blockNumber: 0.5 },
      ]

      expect(getLatestTransaction(transactions)).toEqual({
        blockNumber: 100000000001,
      })
    })
  })

  describe('transactionToKeyStatus', () => {
    describe('mined transactions', () => {
      it('returns CONFIRMING if not all required confirmations have occurred', () => {
        expect.assertions(1)
        const transaction: any = {
          status: TransactionStatus.MINED,
          confirmations: 3,
        }
        expect(transactionToKeyStatus(transaction, 6)).toEqual(
          KeyStatus.CONFIRMING
        )
      })

      it('returns VALID if all required confirmations have occurred', () => {
        expect.assertions(1)
        const transaction: any = {
          status: TransactionStatus.MINED,
          confirmations: 6,
        }
        expect(transactionToKeyStatus(transaction, 6)).toEqual(KeyStatus.VALID)
      })
    })

    describe('other transactions', () => {
      it('converts the transaction status if present', () => {
        expect.assertions(1)
        const transaction: any = {
          status: TransactionStatus.PENDING,
          confirmations: 16,
        }
        expect(transactionToKeyStatus(transaction, 6)).toEqual(
          KeyStatus.PENDING
        )
      })

      it('returns NONE if transaction status is undefined', () => {
        expect.assertions(1)
        const transaction: any = {}
        expect(transactionToKeyStatus(transaction, 6)).toEqual(KeyStatus.NONE)
      })
    })
  })

  describe('getHighestStatus', () => {
    // Test cases generated by shuffling slices of possible statuses
    // with a given expected precedence
    const testCases = [
      [
        ['pending', 'confirming', 'expired', 'valid', 'submitted'],
        KeyStatus.VALID,
      ],
      [['submitted', 'pending', 'expired', 'confirming'], KeyStatus.CONFIRMING],
      [['expired', 'pending', 'submitted'], KeyStatus.PENDING],
      [['submitted', 'expired'], KeyStatus.SUBMITTED],
      [['expired'], KeyStatus.EXPIRED],
      [[], KeyStatus.NONE],
    ]
    it.each(testCases)(
      'given [%s] it returns %s',
      (statuses, expectedResult) => {
        expect.assertions(1)
        expect(getHighestStatus(statuses as any)).toEqual(expectedResult)
      }
    )
  })

  describe('getKeyStatus', () => {
    describe('keys with no transactions', () => {
      it('returns VALID if the key is valid', () => {
        expect.assertions(1)

        const key: any = {
          // Now + 500 seconds
          expiration: new Date().getTime() + 500000,
        }

        expect(getKeyStatus(key, [], 6)).toEqual(KeyStatus.VALID)
      })

      it('returns NONE if the key is not valid', () => {
        expect.assertions(1)

        const key: any = {
          expiration: 0,
        }

        expect(getKeyStatus(key, [], 6)).toEqual(KeyStatus.NONE)
      })
    })

    describe('keys with transactions', () => {
      it('returns EXPIRED if previously owned key has expired', () => {
        expect.assertions(1)

        const key: any = {
          expiration: 1500,
        }

        const transactions: any = [{}]

        expect(getKeyStatus(key, transactions, 6)).toEqual(KeyStatus.EXPIRED)
      })

      it('returns VALID if the key is valid and confirmed', () => {
        expect.assertions(1)

        const key: any = {
          // Now + 500 seconds
          expiration: new Date().getTime() + 500000,
          lock: 'lock',
        }

        const transactions: any = [
          {
            blockNumber: 1,
            lock: 'lock',
            status: TransactionStatus.MINED,
            confirmations: 43,
          },
        ]

        expect(getKeyStatus(key, transactions, 6)).toEqual(KeyStatus.VALID)
      })
    })
  })
})
